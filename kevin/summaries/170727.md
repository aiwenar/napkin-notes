## Best Docs to Date
- [API usage overview](https://github.com/openstax/napkin-notes/blob/master/kevin/160921_biglearnApis/api_usage.md)
- [BL deployment overview](https://github.com/openstax/napkin-notes/blob/master/kevin/BiglearnArchitectureDeployment.pdf)
- [Drew's presentation](https://docs.google.com/presentation/d/1qoPqBLD4XqOsIfcM6aJH7IaDQRsxxuA6QBLy4GIZy7w/edit#slide=id.p)
- [Kevin's SPARFA Guide](https://github.com/openstax/sparfa-sandbox/blob/master/klb_sparfa_guide/sparfa_guide.pdf)

## Dev/Testing/Release Woes

### Background

I have been looking at possible solutions
to the development, testing and deployment issues
raised in:
* [Tutor deployment retrospective](https://docs.google.com/document/d/1aLEMaQ5h75_yXwa1CKJ5CBwTx29bpgiyKOEf3OIPswo/edit#heading=h.p5pj3pqfsjke)
* [Tutor staging issues](https://docs.google.com/document/d/12VFc5ObJNl8KkwzYfOVw42O-D8PYYgxRBb06MHPdXok/edit#heading=h.gp1neznpamzs)

These issues include:
* migrations taking longer than expected in production
* surprise data in production
* queries taking longer in production than on staging
* the schedule pressures incurred by large releases
* choosing the correct environment to test specific aspects of the system
* quickly applying hotfixes
* protection of PII

We (OpenStax) have previously discussed many of these issues
at varying levels of detail:
* [BL Scale and Sustain](https://docs.google.com/document/d/1fmSlXJ1kwxJHXO9dvSskODixDQYTs6pnQe03mWsHchk/edit#heading=h.wfp1mks4mpv4)
* [Technical Debt in Tutor/BL](https://docs.google.com/document/d/1QjoopHF-VGv2WbLIKT4kYehZ3OKLIgcsn24iaC7Laqw/edit)
* [BL/Tutor Architecture Vision](https://docs.google.com/document/d/1K6v5_Ua_kQvg9UzuRejzqOfsbIfQhw8Zy8iriygyPTw/edit#heading=h.yxvxbjnoy1pg)
* pretty much every deployment retrospective

### Rough Thought Process

#### Separation of Development and Deployment Schedules

We want to deploy things:
* when they're ready
  * developed
  * tested
  * QA/UX approved
* on some sort of schedule
* to some or all users

To do this, we will need:
* CI (continuous integration - code is always merged to master)
* CDel (continuous delivery - code is always considered deployable)
* component architecture (to allow pieces to be deployed and analyzed before being switched on)

We don't necessarily want:
* CDep (continuous deployment - code is always immediately deployed)
because we (at least right now) want a human in the loop.

To get CI/CDel we need:
* feature toggles (to allow merging of partially-implemented features)
* fast, reliable and fully-automated test suite (if the tests pass, the code is considered deployable)

#### Fast, Reliable and Fully-Automated Test Suite

This virtually requires us to do real TDD (Test-Driven Development),
and really it means BDD (Behavior-Driven Development),
which is like TDD at the feature level.
We currently do a fairly reasonable flavor of TDD,
which we'd need to level-up,
but we don't really do BDD
in any meaningful way.

####

### Bottom Line(s)
